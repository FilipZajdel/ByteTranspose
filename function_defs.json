{
    "TransposeBits_16xI8_to_8xI16": {
        "body": [
            "void WINAPI TransposeBits_16xI8_to_8xI16(BYTE *pbSource, DWORD count)",
            "{",
            "   BYTE a[8], b[8];",
            "   WORD tmp_dest[8];",
            "",
            "   for (DWORD j = 0; j < count; j++)",
            "   {",
            "",
            "      TransposeByte8x8(pbSource + 0, a);",
            "      TransposeByte8x8(pbSource + 8, b);",
            "",
            "      for (char i = 0; i < 8; i++)",
            "      {",
            "          tmp_dest[i] = (a[i] << 8) | (b[i] << 0);",
            "      }",
            "",
            "      for (char i = 0; i < 16; i++)",
            "      {",
            "          pbSource[i] = ((BYTE *)tmp_dest)[i];",
            "      }",
            "",
            "       pbSource += 16;",
            "   }",
            "}"
        ],
        "details": ""
    },
    "Deinterleve_14x8Words_to_8x14Word": {
        "body": [
            "void WINAPI Deinterleve_14x8Words_to_8x14Words(WORD *pwSource, DWORD count)",
            "{",
            "   WORD tmp[8][14];",
            "",
            "   for (DWORD c = 0; c < count; c++)",
            "   {",
            "      for (DWORD i = 0; i < 8; i++)",
            "      {",
            "       for (DWORD j = 0; j < 14; j++)",
            "        {",
            "            tmp[i][j] = pwSource[(j * 8) + i];",
            "        }",
            "    }",
            "",
            "    for (DWORD i = 0; i < 8 * 14; i++)",
            "    {",
            "        pwSource[i] = ((WORD *)tmp)[i];",
            "    }",
            "    pwSource += 14 * 8;",
            "   }",
            "}"
        ],
        "details": ""
    },
    "TransposeBits_14xI16_to_16xI16": {
        "body": [
            "void WINAPI TransposeBits_14xI16_to_16xI16(WORD *source, WORD *destination, DWORD chunks)",
            "{",
            "    WORD row;",
            "",
            "    for (DWORD chunk_ctr = 0; chunk_ctr < chunks; chunk_ctr++)",
            "    {",
            "        for (BYTE i = 0; i < 16; i++)",
            "        {",
            "            destination[i] = 0;",
            "        }",
            "",
            "        for (BYTE row_ix = 0; row_ix < 14; row_ix++)",
            "        {",
            "            row = source[row_ix];",
            "            for (BYTE col_ix = 0; col_ix < 16; col_ix++)",
            "            {",
            "                destination[col_ix] <<= 1;",
            "                destination[col_ix] |= row & 0x0001;",
            "                row >>= 1;",
            "            }",
            "        }",
            "        source += 14;",
            "        destination += 16;",
            "    }",
            "}"
        ],
        "details": "Maximum vector size is lower than the one used by other tests due to necessity of allocating 2 identical buffers in order to execute test. RPi which was used in these tests has 2GB ram, which is not enough to allocate 2 * 1.07GB."
    },
    "Deinterleve_16Bytes_to_2x8Bytes": {
        "body": [
            "void WINAPI Deinterleve_16Bytes_to_2x8Bytes(BYTE *pbSource, DWORD count)",
            "{",
            "    BYTE lsb[8], msb[8];",
            "",
            "    for (DWORD i = 0; i < count; i++)",
            "    {",
            "        for (char j = 0; j < 8; j++)",
            "        {",
            "            lsb[j] = pbSource[j * 2];",
            "            msb[j] = pbSource[(j * 2) + 1];",
            "        }",
            "        for (char j = 0; j < 8; j++)",
            "        {",
            "            pbSource[j] = lsb[j];",
            "            pbSource[j + 8] = msb[j];",
            "        }",
            "        pbSource += 16;",
            "    }",
            "}"
        ],
        "details": ""
    },
    "decode_chip_byte_stream_to_pixel_array": {
        "body": [
            "def decode_chip_byte_stream_to_pixel_array(byte_stream):",
            "    len_byte_stream = len(byte_stream)",
            "    Deinterleve_16Bytes_to_2x8Bytes(byte_stream,len_byte_stream//16)",
            "    TransposeBits_16xI8_to_8xI16(byte_stream,len_byte_stream//16)",
            "    byte_stream = cast(byte_stream, POINTER(WORD))",
            "    Deinterleve_14x8Words_to_8x14Words(byte_stream,len_byte_stream//(14*8*2))",
            "",
            "    ctrs = (WORD * ((len_byte_stream*16)//14//2))()",
            "    TransposeBits_14xI16_to_16xI16(byte_stream,ctrs,len(ctrs)//16)",
            "    ",
            "    ctrs = np.ctypeslib.as_array(ctrs)",
            "    return ctrs.reshape((len(ctrs)//(2*256*128),2,256,128)) # frame,ctr,column,row"
        ],
        "details": "This function uses: Deinterleve_16Bytes_to_2x8Bytes, TransposeBits_14xI16_to_16xI16, Deinterleve_14x8Words_to_8x14Words, TransposeBits_16xI8_to_8xI16. Timing of this function is approximately equal to the sum of single invocations of mentioned functions for given platform, os and vector size."
    }
}