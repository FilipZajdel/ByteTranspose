<head><link rel="icon" href="static/img/logo.ico" /><meta charset="UTF-8" /><style>  body {                    font-family: "Courier New", Courier, "Lucida Sans Typewriter"                 }                                 table, th, td{                 border:1px solid gray;                 border-collapse: collapse;                }                 .chapter {                   font-size: 180%;                   text-align: center;                   font-weight: bold;                 }                                 .description {                  padding: 1%;                   margin:auto;                   width: 70%;                   font-size:120%;                }                .tooltip {                  position: relative;                  display: block;                   font-size: 180%;                   text-align: center;                 }                .tooltip .tooltiptext {                  visibility: hidden;                  background-color: #ccffff;                  color: black;                  font-weight: normal;                  font-size: 50%;                  text-align: left;                  white-space: pre;                  border-radius: 6px;                  padding: 3px;                  border: 2px solid black;                                    /* Position the tooltip */                  position: absolute;                  z-index: 1;                  top: 102%;                  left: 0%;                  margin-top: -1px;                }                .tooltip:hover .tooltiptext {                  visibility: visible;                 }</style><title>Byte Transpose Performance Tests</title></head><body style="margin: 0; background: url(&quot;static/img/prism.png&quot;) fixed; color: black; font-family: Courier New,Courier,Lucida Sans Typewriter,Lucida Typewriter,monospace;"><header style="background: linear-gradient(180deg, rgba(2,0,36,0.5) 0%, rgba(168,168,168,0.5) 0%, rgba(255,255,255,0.5) 100%); color: black"><br /><p style="text-align: center; font-size: 250%; font-weight: bold;">Performance tests of C functions</p><p style="text-align: center; font-size: 120%;">Project implemented in cooperation with Mirosław Żołądź phD at the AGH University of Science and Technology</p><div style="margin: auto;"><table style="margin: auto; border: 0px; font-size: 100%; font-weight: normal"><col width="250" /><col width="250" /><tr style="border: 0px"><th style="border: 0px">Sources: <a href="https://github.com/FilipZajdel/ByteTranspose" style="text-decoration:none">Github</a></th><th style="border: 0px">Author: Filip Zajdel</th><th style="border: 0px">Contact: filipzajdel@student.agh.edu.pl</th></tr></table></div><br /></header><div style="margin: auto; width: 70%; color: rgb(25, 20, 20); padding-left: 2%; padding-right: 2%; padding-top: 2%;"><br /><br /><div class="chapter">-- About Tests --</div><div class="description">The goal was to measure execution time of some pieces of C code across different devices,                    operating systems and compilers.</div><br /><div class="chapter">-- Device Configuration --</div><div class="description">Tests were executed on Raspberry Pi 4 (RPi) with Linux installed and one PC with both                Linux and Windows installed.</div><br /><div class="chapter">-- Results --</div><br /><br /><div style="margin: 5% auto auto auto; font-size:100%; width: 70%;"><span class="tooltip">decode_chip_byte_stream_to_pixel_array()<span class="tooltiptext">def decode_chip_byte_stream_to_pixel_array(byte_stream):
    len_byte_stream = len(byte_stream)
    Deinterleve_16Bytes_to_2x8Bytes(byte_stream,len_byte_stream//16)
    TransposeBits_16xI8_to_8xI16(byte_stream,len_byte_stream//16)
    byte_stream = cast(byte_stream, POINTER(WORD))
    Deinterleve_14x8Words_to_8x14Words(byte_stream,len_byte_stream//(14*8*2))

    ctrs = (WORD * ((len_byte_stream*16)//14//2))()
    TransposeBits_14xI16_to_16xI16(byte_stream,ctrs,len(ctrs)//16)
    
    ctrs = np.ctypeslib.as_array(ctrs)
    return ctrs.reshape((len(ctrs)//(2*256*128),2,256,128)) # frame,ctr,column,row</span></span></div><div style="margin-left: auto; margin-top: 2%; margin-right: auto; margin-bottom: 2%; text-align: center; width: 70%; font-size: 150%;"><table style="width: 100%; margin: auto; text-align: center"><tr><td rowspan="2">Device</td><td rowspan="2">OS</td><td colspan="4">Execution speed (MB/s)<p style="color: rgb(120, 20, 20)">for vector sizes (MB)</p></td></tr><tr><td style="color: rgb(120, 20, 20)">109</td><td style="color: rgb(120, 20, 20)">219</td><td style="color: rgb(120, 20, 20)">547</td><td style="color: rgb(120, 20, 20)">1096</td></tr><tr><td>PC</td><td>Windows</td><td>62</td><td>61</td><td>59</td><td>56</td></tr><tr><td>PC</td><td>Linux</td><td>12</td><td>13</td><td>13</td><td>13</td></tr><tr><td>Rpi</td><td>Linux</td><td>5</td><td>5</td><td>5</td><td>5</td></tr></table></div><div style="margin: auto; font-size:100%; margin: left; width: 70%;"><p style="font-size: 120%; text-align: justify">This function uses: Deinterleve_16Bytes_to_2x8Bytes, TransposeBits_14xI16_to_16xI16, Deinterleve_14x8Words_to_8x14Words, TransposeBits_16xI8_to_8xI16. Timing of this function is approximately equal to the sum of single invocations of mentioned functions for given platform, os and vector size.</p></div><div style="margin: 5% auto auto auto; font-size:100%; width: 70%;"><span class="tooltip">Deinterleve_16Bytes_to_2x8Bytes()<span class="tooltiptext">void WINAPI Deinterleve_16Bytes_to_2x8Bytes(BYTE *pbSource, DWORD count)
{
    BYTE lsb[8], msb[8];

    for (DWORD i = 0; i &lt; count; i++)
    {
        for (char j = 0; j &lt; 8; j++)
        {
            lsb[j] = pbSource[j * 2];
            msb[j] = pbSource[(j * 2) + 1];
        }
        for (char j = 0; j &lt; 8; j++)
        {
            pbSource[j] = lsb[j];
            pbSource[j + 8] = msb[j];
        }
        pbSource += 16;
    }
}</span></span></div><div style="margin-left: auto; margin-top: 2%; margin-right: auto; margin-bottom: 2%; text-align: center; width: 70%; font-size: 150%;"><table style="width: 100%; margin: auto; text-align: center"><tr><td rowspan="2">Device</td><td rowspan="2">OS</td><td colspan="4">Execution speed (MB/s)<p style="color: rgb(120, 20, 20)">for vector sizes (MB)</p></td></tr><tr><td style="color: rgb(120, 20, 20)">109</td><td style="color: rgb(120, 20, 20)">219</td><td style="color: rgb(120, 20, 20)">547</td><td style="color: rgb(120, 20, 20)">1096</td></tr><tr><td>PC</td><td>Windows</td><td>864</td><td>785</td><td>895</td><td>920</td></tr><tr><td>PC</td><td>Linux</td><td>265</td><td>267</td><td>267</td><td>266</td></tr><tr><td>Rpi</td><td>Linux</td><td>82</td><td>70</td><td>83</td><td>70</td></tr></table></div><div style="margin: auto; font-size:100%; margin: left; width: 70%;"><p style="font-size: 120%; text-align: justify"></p></div><div style="margin: 5% auto auto auto; font-size:100%; width: 70%;"><span class="tooltip">TransposeBits_16xI8_to_8xI16()<span class="tooltiptext">void WINAPI TransposeBits_16xI8_to_8xI16(BYTE *pbSource, DWORD count)
{
   BYTE a[8], b[8];
   WORD tmp_dest[8];

   for (DWORD j = 0; j &lt; count; j++)
   {

      TransposeByte8x8(pbSource + 0, a);
      TransposeByte8x8(pbSource + 8, b);

      for (char i = 0; i &lt; 8; i++)
      {
          tmp_dest[i] = (a[i] &lt;&lt; 8) | (b[i] &lt;&lt; 0);
      }

      for (char i = 0; i &lt; 16; i++)
      {
          pbSource[i] = ((BYTE *)tmp_dest)[i];
      }

       pbSource += 16;
   }
}</span></span></div><div style="margin-left: auto; margin-top: 2%; margin-right: auto; margin-bottom: 2%; text-align: center; width: 70%; font-size: 150%;"><table style="width: 100%; margin: auto; text-align: center"><tr><td rowspan="2">Device</td><td rowspan="2">OS</td><td colspan="4">Execution speed (MB/s)<p style="color: rgb(120, 20, 20)">for vector sizes (MB)</p></td></tr><tr><td style="color: rgb(120, 20, 20)">109</td><td style="color: rgb(120, 20, 20)">219</td><td style="color: rgb(120, 20, 20)">547</td><td style="color: rgb(120, 20, 20)">1096</td></tr><tr><td>PC</td><td>Windows</td><td>241</td><td>222</td><td>186</td><td>247</td></tr><tr><td>PC</td><td>Linux</td><td>92</td><td>93</td><td>93</td><td>92</td></tr><tr><td>Rpi</td><td>Linux</td><td>21</td><td>22</td><td>22</td><td>22</td></tr></table></div><div style="margin: auto; font-size:100%; margin: left; width: 70%;"><p style="font-size: 120%; text-align: justify"></p></div><div style="margin: 5% auto auto auto; font-size:100%; width: 70%;"><span class="tooltip">Deinterleve_14x8Words_to_8x14Word()<span class="tooltiptext">void WINAPI Deinterleve_14x8Words_to_8x14Words(WORD *pwSource, DWORD count)
{
   WORD tmp[8][14];

   for (DWORD c = 0; c &lt; count; c++)
   {
      for (DWORD i = 0; i &lt; 8; i++)
      {
       for (DWORD j = 0; j &lt; 14; j++)
        {
            tmp[i][j] = pwSource[(j * 8) + i];
        }
    }

    for (DWORD i = 0; i &lt; 8 * 14; i++)
    {
        pwSource[i] = ((WORD *)tmp)[i];
    }
    pwSource += 14 * 8;
   }
}</span></span></div><div style="margin-left: auto; margin-top: 2%; margin-right: auto; margin-bottom: 2%; text-align: center; width: 70%; font-size: 150%;"><table style="width: 100%; margin: auto; text-align: center"><tr><td rowspan="2">Device</td><td rowspan="2">OS</td><td colspan="4">Execution speed (MB/s)<p style="color: rgb(120, 20, 20)">for vector sizes (MB)</p></td></tr><tr><td style="color: rgb(120, 20, 20)">109</td><td style="color: rgb(120, 20, 20)">219</td><td style="color: rgb(120, 20, 20)">547</td><td style="color: rgb(120, 20, 20)">1096</td></tr><tr><td>PC</td><td>Windows</td><td>3387</td><td>3103</td><td>3248</td><td>3315</td></tr><tr><td>PC</td><td>Linux</td><td>310</td><td>309</td><td>312</td><td>155</td></tr><tr><td>Rpi</td><td>Linux</td><td>77</td><td>77</td><td>77</td><td>78</td></tr></table></div><div style="margin: auto; font-size:100%; margin: left; width: 70%;"><p style="font-size: 120%; text-align: justify"></p></div><div style="margin: 5% auto auto auto; font-size:100%; width: 70%;"><span class="tooltip">TransposeBits_14xI16_to_16xI16()<span class="tooltiptext">void WINAPI TransposeBits_14xI16_to_16xI16(WORD *source, WORD *destination, DWORD chunks)
{
    WORD row;

    for (DWORD chunk_ctr = 0; chunk_ctr &lt; chunks; chunk_ctr++)
    {
        for (BYTE i = 0; i &lt; 16; i++)
        {
            destination[i] = 0;
        }

        for (BYTE row_ix = 0; row_ix &lt; 14; row_ix++)
        {
            row = source[row_ix];
            for (BYTE col_ix = 0; col_ix &lt; 16; col_ix++)
            {
                destination[col_ix] &lt;&lt;= 1;
                destination[col_ix] |= row &amp; 0x0001;
                row &gt;&gt;= 1;
            }
        }
        source += 14;
        destination += 16;
    }
}</span></span></div><div style="margin-left: auto; margin-top: 2%; margin-right: auto; margin-bottom: 2%; text-align: center; width: 70%; font-size: 150%;"><table style="width: 100%; margin: auto; text-align: center"><tr><td rowspan="2">Device</td><td rowspan="2">OS</td><td colspan="4">Execution speed (MB/s)<p style="color: rgb(120, 20, 20)">for vector sizes (MB)</p></td></tr><tr><td style="color: rgb(120, 20, 20)">109</td><td style="color: rgb(120, 20, 20)">219</td><td style="color: rgb(120, 20, 20)">547</td><td style="color: rgb(120, 20, 20)">766</td></tr><tr><td>PC</td><td>Windows</td><td>98</td><td>98</td><td>98</td><td>95</td></tr><tr><td>PC</td><td>Linux</td><td>18</td><td>18</td><td>18</td><td>18</td></tr><tr><td>Rpi</td><td>Linux</td><td>8</td><td>8</td><td>8</td><td>8</td></tr></table></div><div style="margin: auto; font-size:100%; margin: left; width: 70%;"><p style="font-size: 120%; text-align: justify">Maximum vector size is lower than the one used by other tests due to necessity of allocating 2 identical buffers in order to execute test. RPi which was used in these tests has 2GB ram, which is not enough to allocate 2 * 1.07GB.</p></div></div></body>